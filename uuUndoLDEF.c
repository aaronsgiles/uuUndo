#include <A4Stuff.h>#include <QDOffscreen.h>static OSErr FindIcon(OSType creator, OSType type);static char gIconBuffer[1024];static GWorldPtr gTheGWorld = nil;static OSType gIconType = kLargeIcon;static Rect gIconBounds = { 0, 0, 32, 32 };pascal void main(short message, Boolean selected, Rect *cellRect, Cell theCell, 			short dataOffset, short dataLen, ListHandle theList){	long oldA4 = SetCurrentA4();	char cellData[16];	RgnHandle oldClip;	PenState oldState;	FontInfo theInfo;	GrafPtr oldPort;	Point thePoint;	OSErr theErr;	short depth;	switch (message) {		case lInitMsg:			if (((CGrafPtr)(*theList)->port)->portVersion & 0xc000) {				GDHandle mostDevice;				GrafPtr oldPort;				Rect globalRect;				GetPort(&oldPort);				SetPort((*theList)->port);				globalRect = (*theList)->port->portRect;				LocalToGlobal((Point *)&globalRect.top);				LocalToGlobal((Point *)&globalRect.bottom);				mostDevice = GetMaxDevice(&globalRect);				depth = (*(*mostDevice)->gdPMap)->pixelSize;				if (depth == 4) gIconType = kLarge4BitIcon, depth = 4;				else if (depth > 4) gIconType = kLarge8BitIcon, depth = 8;				else gIconType = kLargeIcon, depth = 1;				SetPort(oldPort);			} else gIconType = kLargeIcon, depth = 1;			theErr = NewGWorld(&gTheGWorld, depth, &gIconBounds, nil, nil, 0);			if (theErr != noErr || !gTheGWorld)				theErr = NewGWorld(&gTheGWorld, depth, &gIconBounds, nil, nil, useTempMem);			break;					case lDrawMsg:			GetPort(&oldPort);			SetPort((*theList)->port);			oldClip = NewRgn();			GetClip(oldClip);			ClipRect(cellRect);			GetPenState(&oldState);			PenNormal();			EraseRect(cellRect);			if (dataLen == 16) {				LGetCell(cellData, &dataLen, theCell, theList);				GetFontInfo(&theInfo);				thePoint.h = cellRect->left + 5;				thePoint.v = cellRect->top +							((34 - (theInfo.ascent + theInfo.leading + theInfo.descent)) / 2) +							theInfo.ascent;				MoveTo(thePoint.h, thePoint.v);				DrawString((StringPtr)cellData);				thePoint.h += 87;				MoveTo(thePoint.h, thePoint.v);				DrawText((StringPtr)cellData, 10, 4);				DrawChar('/');				DrawText((StringPtr)cellData, 6, 4);			}			theErr = FindIcon(*(long *)&cellData[10], *(long *)&cellData[6]);			if (theErr == noErr) {				PixMapHandle thePixMap = GetGWorldPixMap(gTheGWorld);				Rect dstRect = *cellRect;				LockPixels(thePixMap);				dstRect.right -= 5;				dstRect.left = dstRect.right - 32;				dstRect.top++;				dstRect.bottom = dstRect.top + 32;				CopyBits((BitMap *)*thePixMap, &(*theList)->port->portBits,					&gIconBounds, &dstRect, srcCopy, nil);				UnlockPixels(thePixMap);			}			if (selected) {				LMSetHiliteMode(LMGetHiliteMode() & ~(1 << hiliteBit));				InvertRect(cellRect);			}			SetPenState(&oldState);			SetClip(oldClip);			DisposeRgn(oldClip);			SetPort(oldPort);			break;					case lHiliteMsg:			LMSetHiliteMode(LMGetHiliteMode() & ~(1 << hiliteBit));			InvertRect(cellRect);			break;					case lCloseMsg:			if (gTheGWorld) DisposeGWorld(gTheGWorld), gTheGWorld = nil;			break;	}	SetA4(oldA4);}OSErr FindIcon(OSType creator, OSType type){	ParamBlockRec vol;	DTPBRec dt;	Str255 path;	OSErr theErr;	if (!gTheGWorld) return memFullErr;	vol.volumeParam.ioCompletion = nil;	vol.volumeParam.ioVolIndex = 1;	vol.volumeParam.ioNamePtr = path;		while (true) {		vol.volumeParam.ioVRefNum = 0;		theErr = PBGetVInfoSync(&vol);				if (theErr != noErr) break;				dt.ioVRefNum = vol.volumeParam.ioVRefNum;		dt.ioNamePtr = path;		theErr = PBDTGetPath(&dt);				if (theErr != noErr) continue;				dt.ioCompletion = nil;		dt.ioDTBuffer = gIconBuffer;		dt.ioDTReqCount = 1024;		dt.ioIconType = gIconType;		dt.ioFileCreator = creator;		dt.ioFileType = type;		theErr = PBDTGetIconSync(&dt);		if (theErr == noErr && gTheGWorld) {			PixMapHandle thePixMap = GetGWorldPixMap(gTheGWorld);			char *src, *dst;			short row, size;			LockPixels(thePixMap);			src = gIconBuffer;			dst = GetPixBaseAddr(thePixMap);			size = 32 * (*thePixMap)->pixelSize / 8;			for (row = 0; row < 32; row++) {				BlockMove(src, dst, size);				src += size;				dst += (*thePixMap)->rowBytes & 0x3fff;			}			UnlockPixels(thePixMap);			return noErr;		}				vol.volumeParam.ioVolIndex++;	}}